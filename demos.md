# Waterfall Stream Scheduler Demo

The gif generator demonstrates the dependency chain and likely scheduling path of the stream (rows) and waterfall (columns). This visual was generated by instructing GPT-5, hence the code bloat.

    
![png](grid_anim.gif)


The only dependency of this scheduler is that at a given yellow square along row i and column j, must have results returned for all $0$ to $i - 1$ rows and $0$ to $j$ columns. Note that tasks from the same row $i$ do **not** have to be processed first, this is somewhat demonstrated by the first row finishing simultaneously. This allows stream tasks to finish at unordered times but still provide ordered results, it's only this grid dependency that needs to be satisfied before the task is scheduled. The animation demonstrates a strict breadth first search starting at square/node (1,0), in a real setting all of row 1 may be scheduled (turn yellow) nearly simultaneously, corresponding with availability. This means that depending on how much concurrency and compute division is available, you will achieve the most throughput by sorting the processing stages from least to most time and assign them descending to each row.

# Provider Decorator for Static Dict - Demo


```python
from typing import List, Optional, Sequence, Tuple, Collection
from generics import provider_factory,ProviderSpec

#A global dict, we want the args of the dict to be the same, but don't care if it's modifiable
g_dict={1:'h',2:'l',5:'test'}

#multiple strategies
# 1.
class ProvideDict(ProviderSpec):
    #we use instance instead of class methods and parameters, for easier genericity.
    def call(self): return g_dict.copy() # as it shouldn't modify we dont need: global g_dict
    
Ps1=ProvideDict() #optional: provider_type=dict,provider_kwargs=('dic','dic1')
# 2.
Ps2=ProviderSpec(g_dict.copy(),provider_kwargs=('dic1','dic'))

d_prov1=provider_factory(Ps1,kwarg_names=('dic1','dic'))
d_prov2=provider_factory(Ps2)

#@d_prov1
def test_modify1(somt,somt1=5,dic1:dict=None):
    print(f'Test 1,{somt} dict before:',dic1)
    dic1[somt1]=somt
    print(f'Test 1,{somt} dict after:',dic1)

test_m1p1=d_prov1(test_modify1)
test_m1p2=d_prov2(test_modify1)

print('Calling decorated dict modification:')
test_m1p1(1,)
test_m1p2(2,)
print('global dict:',g_dict)
print('\nCalling test_m1p2 a second time:')
test_m1p2(3,)
print('global dict:',g_dict)

print('\nWithout decorators:')
def test_b(somt,somt1=5,dic1:dict=g_dict):
    print(f'Test b,{somt} dict before:',dic1)
    dic1[somt1]=somt
    print(f'Test b,{somt} dict after:',dic1)
test_b(1)
test_b(2)
print('global dict:',g_dict)


#Now if we want to change the object instance of global dict?
def chg_forp1():
    global g_dict
    g_dict={1:'l',2:'l',5:'test'} #all that is needed for our override class
    #note how we don't need to reference the provider instance.
    #if our type is not the same, eg we turn it into another collection, need to call:
    del Ps1.provider_type

def chg_forp2():
    global g_dict
    g_dict={1:'l',2:'l',5:'test'}
    Ps2.new_instance(g_dict.copy())
    #the difference between the first and second method boils down to a static reference or per object ref.
    
chg_forp1()
chg_forp2()
print('\nAfter Reset:')
test_m1p2(2,)
print('global dict:',g_dict)

@d_prov1('dic2')
def test_m2p1(somt,somt1=5,dic2:dict=None):
    print(f'Test 2,{somt} dict before:',dic2)
    dic2[somt1]=somt
    print(f'Test 2,{somt} dict after:',dic2)

print('\nDecorator with non-default kwarg spec:')
test_m2p1(1,)


class ProvideDict2(ProviderSpec):
    #we use instance instead of class methods and parameters, for easier genericity.
    def call(self): return g_dict.copy() # as it shouldn't modify we dont need: global g_dict
    def provider_type(self): return type(self()) #assuming it's cheap enough
    
#base class example:
class ProvideDict3(ProviderSpec):
    #we use instance instead of class methods and parameters, for easier genericity.
    def call(self): return g_dict.copy() # as it shouldn't modify we dont need: global g_dict
    def provider_type(self): return Collection

d_prov22=provider_factory(ProvideDict2(provider_kwargs=('dic1','dic')))
d_prov3=provider_factory(ProvideDict3(provider_kwargs=('dic1','dic')))

test_m1p22=d_prov22(test_modify1)
test_m1p3=d_prov3(test_modify1)

print('\nTest without type reset:')
test_m1p22(1,1)
test_m1p3(1,1)

g_dict=['h','l','test']
print('\nAfter changing collection type')
test_m1p22(1,1)
test_m1p3(1,1)
print('global list:',g_dict)


```

    Calling decorated dict modification:
    Test 1,1 dict before: {1: 'h', 2: 'l', 5: 'test'}
    Test 1,1 dict after: {1: 'h', 2: 'l', 5: 1}
    Test 1,2 dict before: {1: 'h', 2: 'l', 5: 'test'}
    Test 1,2 dict after: {1: 'h', 2: 'l', 5: 2}
    global dict: {1: 'h', 2: 'l', 5: 'test'}
    
    Calling test_m1p2 a second time:
    Test 1,3 dict before: {1: 'h', 2: 'l', 5: 2}
    Test 1,3 dict after: {1: 'h', 2: 'l', 5: 3}
    global dict: {1: 'h', 2: 'l', 5: 'test'}
    
    Without decorators:
    Test b,1 dict before: {1: 'h', 2: 'l', 5: 'test'}
    Test b,1 dict after: {1: 'h', 2: 'l', 5: 1}
    Test b,2 dict before: {1: 'h', 2: 'l', 5: 1}
    Test b,2 dict after: {1: 'h', 2: 'l', 5: 2}
    global dict: {1: 'h', 2: 'l', 5: 2}
    
    After Reset:
    Test 1,2 dict before: {1: 'l', 2: 'l', 5: 'test'}
    Test 1,2 dict after: {1: 'l', 2: 'l', 5: 2}
    global dict: {1: 'l', 2: 'l', 5: 'test'}
    
    Decorator with non-default kwarg spec:
    Test 2,1 dict before: {1: 'l', 2: 'l', 5: 'test'}
    Test 2,1 dict after: {1: 'l', 2: 'l', 5: 1}
    
    Test without type reset:
    Test 1,1 dict before: {1: 'l', 2: 'l', 5: 'test'}
    Test 1,1 dict after: {1: 1, 2: 'l', 5: 'test'}
    Test 1,1 dict before: {1: 'l', 2: 'l', 5: 'test'}
    Test 1,1 dict after: {1: 1, 2: 'l', 5: 'test'}
    
    After changing collection type
    Test 1,1 dict before: ['h', 'l', 'test']
    Test 1,1 dict after: ['h', 1, 'test']
    Test 1,1 dict before: ['h', 'l', 'test']
    Test 1,1 dict after: ['h', 1, 'test']
    global list: ['h', 'l', 'test']
    


```python

```
